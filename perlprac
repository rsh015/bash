#!/bb/util/bin/perl
 
use strict;
use warnings;
$| = 1;
use LWP::UserAgent;
use HTTP::Request::Common qw(POST);
use XML::Simple;
use Getopt::Long;
use Socket qw(inet_aton inet_ntoa);
use Term::ReadKey;
use Term::ANSIColor qw(:constants);
use Pod::Usage;
use Net::MAC;
use BDMS;
use Term::ANSIColor qw(:constants);
use JSON::PP;
use DCSI::Sudo;
 
#Global and constants
my ($DEBUG,$BATCH);
use constant {
    JSON_CONFIG_FILE    => '/bb/data/confsettings.json',
    CURL                => '/opt/swt/bin/curl',
    SSHOPTS             => '-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -q',
    DHCP_UPDATE_SCIRPT  => '/bb/bin/dhcp_update',
    PASSWORD_KEY        => '/users/dcsi/.pw/dcsiusr.key',
    PASSWORD_CERT       => '/users/dcsi/.pw/dcsiusr.cert',
    BPV_SCRIPT          => '/bb/bin/py/bpv.py',
    VASTOOL_SCRIPT      => '/opt/quest/bin/vastool',
    DC_ENG_UID          => 9338970,
    UPD_DRQS_SCRIPT     => '/bb/bin/updatedrqs.py'
};
 
#Log $CMD and $ARGS
{
    my $realname = DCSI::Sudo->realname();
    system("/bb/bin/lanlog $0 @ARGV $realname");
}
 
use Net::SSH::Expect;
package Net::SSH::Expect;
sub runit {
    my ($ssh, $cmd, $additional_rcode) = @_;
 
    #Timeouts
    my $timeout = 30;
    $timeout = 10 if defined $BATCH;
 
    main::debug("Running $cmd");
    $ssh->send($cmd);
    unless ($ssh->waitfor('->',$timeout)) {
        return (main::error("Timed out running $cmd"),"Timed out running $cmd");
    }
    
    #Setting original values
    my $rcode = -1;
    my $output = $ssh->before;
    
    #Grabbing output and rcode from the output
    $rcode = $1 if ($output =~ /\bstatus=(\d+)\b/m);
    $output = join "\n", split (/[\r\n]+/, $output);
 
    #If the additional rcode is defined, proceed as normal, else, check stuff
    if (!defined $additional_rcode or $rcode != $additional_rcode) {
        #If the rcode is >0, its a failure!
        if ($rcode > 0) {
            main::error("Did not receive a success message from $cmd:\n$output\n");
        #If we didn't reinitialize rcode, it means the output was bad
        } elsif ($rcode == -1) {
            main::error("Did not receive a status code from $cmd:\n$output\n");
        }
    }
 
    return ($rcode, $output);
}
 
package main;
sub debug { print scalar localtime, ": ", @_, "\n" if $DEBUG;}
sub logit { if ($DEBUG) { print "+ ", (scalar localtime), " " } print @_, "\n"; }
sub warning { if ($DEBUG) { print STDERR "! ", (scalar localtime), " " } print STDERR "[WARNING] @_\n"; }
sub error { if ($DEBUG) { print STDERR "! ", (scalar localtime), " " } die "[ERROR] confilo failed with error: @_\n"; }
 
sub usage {
    my ($usage_message) = @_;
    print RED, BOLD, "$usage_message\n", RESET;
    pod2usage(-verbose => 1);
}
 
sub section_print {
    my ($error_count, $section_name, $failure_array) = @_;
 
    if ($error_count > 0) {
        logit "[" . RED, "FAIL", RESET . "] $section_name";
        push(@$failure_array, "[FAIL] $section_name");
    } else {
        logit "[" . GREEN, "PASS", RESET . "] $section_name";
        unshift(@$failure_array, "[PASS] $section_name");
    }
}
 
sub check_ribcl_ntp {
    my ($ilo, $password, $ntp, $failure_array) = @_;
    my $error = 0;
 
    my $xml = <<XML;
<?xml version="1.0"?>
<RIBCL VERSION="2.22">
 <LOGIN USER_LOGIN="Administrator" PASSWORD="$password">
  <RIB_INFO MODE="read">
   <GET_NETWORK_SETTINGS/>
  </RIB_INFO>
 </LOGIN>
</RIBCL>
XML
 
    my $cmd = CURL . " -skX POST -d '$xml' https://$ilo/ribcl";
    debug "Running $cmd";
    my $output = `$cmd`;
    debug $output;
    my @output = split(/\n/, $output);
 
    my ($sntp1, $sntp2);
    for my $line (@output) {
        if ($line =~ /<SNTP_SERVER1 VALUE="(\d+\.\d+\.\d+\.\d+)"/) {
            $sntp1 = $1;
            debug "SNTP1: $sntp1";
        } elsif ($line =~ /<SNTP_SERVER2 VALUE="(\d+\.\d+\.\d+\.\d+)"/) {
            $sntp2 = $1;
            debug "SNTP2: $sntp2";
        } elsif (defined $sntp1 and defined $sntp2) {
            last;
        }
    }
            
    if (defined $sntp1 and defined $sntp2) {
        warning "SNTP settings aren't per current standard. SNTP set to $sntp1 and $sntp2 instead of $ntp->[0] and $ntp->[1]." and $error++ unless ($sntp1 =~ /$ntp->[0]/ and $sntp2 =~ /$ntp->[1]/);
    } else {
        warning "SNTP settings aren't configured at all." and $error++;
    }
 
    section_print($error, "NTP", $failure_array);
    return $error;
}
 
sub get_targets {
    my ($snmp_settings) = @_;
 
    my %targets = (
        'sim'       => [ $snmp_settings->{sim1}, $snmp_settings->{sim2}, $snmp_settings->{lanserv} ],
        'lanserv'   => [ $snmp_settings->{lanserv}, $snmp_settings->{datacenter} ] 
    );
    
    return %targets;
}
 
sub config_ssh_snmp {
    my ($ssh, $target, $ilo_version, $snmp_settings, $ticket_text) = @_;
    my ($rcode, $output);
 
    my %targets = get_targets($snmp_settings, $ilo_version);
 
    logit "Configuring the SNMP settings.";
 
    #Turning on agentless for iLO4 and passthru for others
    if ($ilo_version == 4) {
        ($rcode, $output) = $ssh->runit("set /map1/snmp1/ oemhp_agentlessenable=yes");
    } else {
        ($rcode, $output) = $ssh->runit("set /map1/snmp1/ oemhp_snmppassthru=yes");
    } 
 
    #Adding all SNMP destinations and if one isn't specified, setting to 0.0.0.0
    for my $i (1..3) {
        my $pos = $i - 1;
        if (exists $targets{$target}[$i-1]) { 
            if ($ilo_version == 4) {
                #Only iLO4 can use alias', the others use hard coded IPs
                ($rcode, $output) = $ssh->runit("set /map1/snmp1/ accessinfo$i=$targets{$target}[$i-1]->{trap_dest}");
                ($rcode, $output) = $ssh->runit("set /map1/snmp1/ readcom${i}=$targets{$target}[$i-1]->{com_read}");
                ($rcode, $output) = $ssh->runit("set /map1/snmp1/ trapcom${i}=$targets{$target}[$i-1]->{com_trap}");
            } else {
                ($rcode, $output) = $ssh->runit("set /map1/snmp1/ accessinfo$i=" . inet_ntoa(inet_aton("$targets{$target}[$i-1]->{trap_dest}")));
                #non-iLO4s can't do read/trap communities
            }
        } else {
            ($rcode, $output) = $ssh->runit("set /map1/snmp1/ accessinfo$i=0.0.0.0");
        }
    }
 
    $$ticket_text .= " $target SNMP settings,";
}
 
sub check_ssh_snmp {
    my ($ssh, $ilo_version, $snmp_settings, $failure_array) = @_;
    my ($rcode, $output, $potential_profile);
    my $error = 0;
 
    my %targets = get_targets($snmp_settings, $ilo_version);
 
    #Checking what type of SNMP its using per iLO version
    if ($ilo_version == 4) {
        ($rcode, $output) = $ssh->runit("show /map1/snmp1/ oemhp_agentlessenable");
        my ($agentless_enabled) = ($output =~ /oemhp_agentlessenable=(\S+)/s);
        warning "SNMP isn't configured correctly for an iLO4." and $error++ unless $agentless_enabled =~ /yes/;
    } else {
        ($rcode, $output) = $ssh->runit("show /map1/snmp1/ oemhp_snmppassthru");
        my ($snmp_passthru) = ($output =~ /oemhp_snmppassthru=(\S+)/s);
        warning "SNMP isn't configured correctly for an iLO3." and $error++ unless $snmp_passthru =~ /yes/;
    }
 
    my $has_match = 0;
    #Loop through all of the targets 
    for my $target_key (keys %targets) {
        my $target_group = $targets{$target_key};
        my $failed = 0;
        my $i = 1;
        for my $target (@{$target_group}) {
            #Grab the size of the array for that profile (amount of LDAP groups)
            my $target_size = scalar @{$target_group};
            #Loop through each LDAP group
            ($rcode, $output) = $ssh->runit("show /map1/snmp1/ accessinfo$i");
            my ($snmp_accessinfo) = ($output =~ /accessinfo$i=(\S+)/m);
            if ($snmp_accessinfo ne $target->{trap_dest}) {
                #If the trap destination doesn't match, go to the next profile
                $failed = 1;
                #Incrementing since it failed
                $i++;
                last;
            }
 
            ($rcode, $output) = $ssh->runit("show /map1/snmp1/ readcom$i");
            my ($readcom) = ($output =~ /readcom$i="(\S+)"/s);
            if ($readcom ne $target->{com_read}) {
                #If the trap destination doesn't match, go to the next profile
                $failed = 1;
                #Incrementing since it failed
                $i++;
                last;
            }
 
            ($rcode, $output) = $ssh->runit("show /map1/snmp1/ trapcom$i");
            my ($trapcom) = ($output =~ /trapcom$i="(\S+)"/s);
            if ($trapcom ne $target->{com_trap}) {
                #If the trap destination doesn't match, go to the next profile
                $failed = 1;
                #Incrementing since it failed
                $i++;
                last;
            }
            
            #Incrementing if it passes all the tests
            $i++;
        }
        if (! $failed) {
            $potential_profile = " - configured for $target_key";
            last;
        }
    }
 
    #If we haven't found a match for a target, alarm
    warning "SNMP groups (--target option) do not appear to match any standard." and $error++ unless $potential_profile;
 
    $potential_profile = "" if !defined $potential_profile;
    section_print($error, "SNMP$potential_profile", $failure_array);
    return $error;
}
 
sub get_profiles {
    my ($ad_names) = @_;
 
    my %profiles = (
        'bach'    => [ $ad_names->{bach},           $ad_names->{dc},            $ad_names->{contractor}, $ad_names->{vendor} ],
        'bfs'     => [ $ad_names->{bfs},            $ad_names->{bach},          $ad_names->{dc},         $ad_names->{contractor}, $ad_names->{vendor} ],
        'cloud'   => [ $ad_names->{cloud},          $ad_names->{dc},            $ad_names->{contractor}, $ad_names->{vendor} ], 
        'bvlt'    => [ $ad_names->{bvlt},           $ad_names->{dc},            $ad_names->{contractor}, $ad_names->{vendor} ],
        'netops'  => [ $ad_names->{netops},         $ad_names->{neteng},        $ad_names->{dc},         $ad_names->{contractor}, $ad_names->{vendor} ],
        'esx'     => [ $ad_names->{virt},           $ad_names->{dc},            $ad_names->{contractor}, $ad_names->{vendor},     $ad_names->{conr}   ],
        'linux'   => [ $ad_names->{linux},          $ad_names->{dc},            $ad_names->{contractor}, $ad_names->{vendor},     $ad_names->{conr}   ],
        'windows' => [ $ad_names->{windows},        $ad_names->{dc},            $ad_names->{contractor}, $ad_names->{vendor},     $ad_names->{conr}   ],
        'infosys' => [ $ad_names->{'pcsu-server'},  $ad_names->{'pcsu-admin'},  $ad_names->{dc},         $ad_names->{contractor}, $ad_names->{vendor} ],
        'cas'     => [ $ad_names->{'cas1'},         $ad_names->{'cas2'},        $ad_names->{dc},         $ad_names->{contractor}, $ad_names->{vendor} ],
        'dc'      => [ $ad_names->{dc},             $ad_names->{contractor},    $ad_names->{vendor},     $ad_names->{conr}   ],
    );
    
    return %profiles;
}
 
sub config_ssh_ldap {
    my ($ssh, $profile, $ilo_version, $ldap_settings, $ticket_text) = @_;
    my ($rcode, $output);
 
    logit "Configuring the LDAP settings.";
 
    my %profiles = get_profiles($ldap_settings->{groups});
 
    error "Profile isn't in the profile list." unless exists $profiles{$profile};
 
    ($rcode, $output) = $ssh->runit("set /map1/oemhp_dircfg1 oemhp_dirsrvaddr=$ldap_settings->{server}");
 
    ($rcode, $output) = $ssh->runit("set /map1/oemhp_dircfg1 oemhp_ldapport=$ldap_settings->{port}");
 
    #Figuring out how many searches we need to set
    my $amount_of_searches;
    for my $i (1..15) {
        $amount_of_searches = $i-1 and last if !exists $ldap_settings->{search}{"string$i"};
    }
 
    #Apply the search strings depending on how many were found above
    for my $i (1..$amount_of_searches) {
        ($rcode, $output) = $ssh->runit("set /map1/oemhp_dircfg1 oemhp_usercntxt$i=\"" . $ldap_settings->{search}{"string$i"} . "\"");
    }
 
    ($rcode, $output) = $ssh->runit("set /map1/oemhp_dircfg1 oemhp_dirauth=default_schema");
 
    if ($ilo_version >= 3) {
        #Checking to see if any LDAP groups are present, if they are, I try removing them until they are gone
        ($rcode, $output) = $ssh->runit("show /map1/oemhp_dircfg1");
        while ($output =~ /oemhp_group\d_name=(\S+)/) {
            #Clearing the LDAP groups before I start setting them
            for my $i (1..6) {
                ($rcode, $output) = $ssh->runit("set /map1/oemhp_dircfg1 oemhp_group${i}_name=0", 2);
            }
 
            ($rcode, $output) = $ssh->runit("show /map1/oemhp_dircfg1");
        }
 
        for my $i (1..6) {
            if ($profiles{$profile}[$i-1]) {
                ($rcode, $output) = $ssh->runit("set /map1/oemhp_dircfg1 oemhp_group${i}_name=\"$profiles{$profile}[$i-1]\"");
                #If they are console room, limit privileges
                if ($profiles{$profile}[$i-1] eq "CN=RBP_30,OU=RBP-Data,OU=Groups,OU=Bloomberg,DC=addev,DC=bloomberg,DC=com") {
                    ($rcode, $output) = $ssh->runit("set /map1/oemhp_dircfg1 oemhp_group${i}_priv=login,oemhp_rc,oemhp_power");
                } else {
                    ($rcode, $output) = $ssh->runit("set /map1/oemhp_dircfg1 oemhp_group${i}_priv=login,oemhp_rc,oemhp_vm,oemhp_power,config,admin");
                }
            }
        }    
    } else {
        logit "Unable to configure LDAP groups because iLO 1 & 2 don't support it, skipping ...";
    }
 
    $$ticket_text .= " $profile LDAP groups,";
}
 
sub check_ssh_ldap {
    my ($ssh, $ilo_version, $ldap_settings, $failure_array) = @_;
    my ($rcode, $output, $potential_profile);
    my $error = 0;
 
    my %profiles = get_profiles($ldap_settings->{groups});
 
    ($rcode, $output) = $ssh->runit("show /map1/oemhp_dircfg1 oemhp_dirsrvaddr");
    my ($ldap_server_address) = ($output =~ /oemhp_dirsrvaddr=(.*)$/m);
    warning "LDAP server address isn't configured correctly. Currently configured for $ldap_server_address." and $error++ unless $ldap_server_address =~ /$ldap_settings->{server}/;
 
    ($rcode, $output) = $ssh->runit("show /map1/oemhp_dircfg1 oemhp_ldapport");
    my ($ldap_port) = ($output =~ /oemhp_ldapport=(.*)$/m);
    warning "LDAP port isn't configured correctly. Currently configured for $ldap_port." and $error++ unless $ldap_port =~ /$ldap_settings->{port}/;
 
    #Grabbing the search contexts
    ($rcode, $output) = $ssh->runit("show /map1/oemhp_dircfg1");
    my @current_config;
    for my $line (split(/\n/, $output)) {
        if ($line =~ /^\s+oemhp_usercntxt(\d+)=(.*)$/) {
            next if $2 =~ /^$/;
            push(@current_config, $2);
        }
    }
 
    #Making sure that the search contexts match
    my $config_size = scalar @current_config;
    for my $i (1..$config_size) {
        last if !exists $ldap_settings->{search}{"string$i"};
        if ($current_config[$i-1] =~ /$ldap_settings->{search}{"string$i"}/) {
            next;
            if ($i == $config_size) {
                print "Last entry and it matched!!!\n";
                last;
            }
        }
        warning "Search context does not appear to match any standard." and $error++ and last;
    }
 
    ($rcode, $output) = $ssh->runit("show /map1/oemhp_dircfg1 oemhp_dirauth");
    my ($ldap_auth) = ($output =~ /oemhp_dirauth=(.*)$/m);
    warning "LDAP directory authorization isn't configured correctly. Currently configured for $ldap_auth." and $error++ unless $ldap_auth =~ /Directory Default Schema/;
 
    #If its running 3 or higher, it supports LDAP
    if ($ilo_version >= 3) {
        my $has_match = 0;
        #Loop through all of the profiles
        for my $profile_key (keys %profiles) {
            my $failed = 0;
            my $profile = $profiles{$profile_key};
            #Grab the size of the array for that profile (amount of LDAP groups)
            my $profile_size = scalar @$profile;
            #Loop through each LDAP group
            for my $i (1..$profile_size) {
                ($rcode, $output) = $ssh->runit("show /map1/oemhp_dircfg1 oemhp_group${i}_name");
                my ($oemhp_group) = ($output =~ /oemhp_group${i}_name=(.*)$/m);
                #If this group matches, go again and see if the next group matches
                if ($oemhp_group ne @$profile[$i-1]) {
                    $failed = 1;
                    #If the groups don't match, go to the next profile
                    last;
                }
            }
            if (! $failed) {
                $potential_profile = " - configured for $profile_key";
                last;
            }
        }
        #If we haven't found a match for a profile, alarm
        warning "LDAP groups (--profile option) do not appear to match any standard." and $error++ unless $potential_profile;
    } else {
        logit "iLO1 and iLO2 do not support LDAP. No checks will be done against it.";
    }
 
    $potential_profile = "" if !defined $potential_profile;
    section_print($error, "LDAP$potential_profile", $failure_array);
    return $error;
}
 
sub config_ssh_accounts {
    my ($ssh) = @_;
    my ($rcode, $output, $ticket_text);
 
    logit "Checking for and if present, removing the do account.";
    ($rcode, $output) = $ssh->runit("show /map1/accounts1/do", 2);
    if ($rcode == 0) {
        ($rcode, $output) = $ssh->runit("delete /map1/accounts1/do");
    }
 
    logit "Creating and configuring the Administrator account.";
    #Configuring the Administrator account
    ($rcode, $output) = $ssh->runit("show /map1/accounts1/Administrator");
    if ($output =~ /<No SSH public key installed>/) {
        my $password = lookup_password("Administrator");
        ($rcode, $output) = $ssh->runit("set /map1/accounts1/Administrator password=$password");
    } else {
        logit "Appears the Administrator account is configured, skipping ...";
    }
 
    $$ticket_text .= " accounts,";
}
 
sub check_ssh_accounts {
    my ($ssh, $failure_array) = @_;
    my ($rcode, $output);
    my $error = 0;
 
    ($rcode, $output) = $ssh->runit("show /map1/accounts1/do", 2);
    if ($rcode == 0) {
        warning "do account is created, please remove." and $error++;
    }
 
    ($rcode, $output) = $ssh->runit("show /map1/accounts1/Administrator");
    if ($output =~ /<No SSH public key installed>/) {
        warning "Administrator account does not appear to have the SSH key." and $error++;
    }
    section_print($error, "ACCOUNTS", $failure_array);
    return $error;
}
 
sub config_ssh_dns {
    my ($ssh, $ilo, $dns, $ticket_text) = @_;
    my ($rcode, $output);
 
    logit "Configuring the DNS settings.";
 
    #Enabling DNS
    ($rcode, $output) = $ssh->runit("set /map1/dnsendpt1 EnabledState=yes");
 
    #Setting DNS host name
    ($rcode, $output) = $ssh->runit("set /map1/dnsendpt1 Hostname=$ilo");
 
    #Setting DNS domain name
    ($rcode, $output) = $ssh->runit("set /map1/dnsendpt1 DomainName=bloomberg.com", 2);
 
    #Looping through all 3 dns servers and if there isn't one, zeroing out the entry
    for my $i (1..3) {
        if (exists $dns->[$i-1]) {
            eval {
                ($rcode, $output) = $ssh->runit("set /map1/dnsserver$i/ AccessInfo=$dns->[$i-1]", 3);
            };
            if ($@ =~ /status=2\s+status_tag=COMMAND PROCESSING FAILED/s) {
                error "Error occured while attempting to set DNS. This is usually caused by DHCP still being enabled. Please rerun with the --dhcp flag to correct those settings.";
            }
        } else {
            ($rcode, $output) = $ssh->runit("set /map1/dnsserver$i/ AccessInfo=0.0.0.0", 3);
        }
    }
 
    $$ticket_text .= " DNS settings,";
}
 
sub check_ssh_dns {
    my ($ssh, $ilo, $dns, $failure_array) = @_;
    my ($rcode, $output);
    my $error = 0;
 
    #Checking DNS server addresses
    for my $i (1..3) {
        ($rcode, $output) = $ssh->runit("show /map1/dnsserver$i/ AccessInfo");
        my ($dns_address) = ($output =~ /\bAccessInfo=(\S+)\b/m);
 
        next if $dns_address =~ /0.0.0.0/ and !defined $dns->[$i-1];
 
        warning "DNS addresses aren't at the current standard. $dns_address should be $dns->[$i-1]." and $error++ unless $dns_address =~ /$dns->[$i-1]/;
    }
 
    ($rcode, $output) = $ssh->runit("show /map1/dnsendpt1");
    my ($dns_state, $dns_hostname, $dns_domain) = ($output =~ /EnabledState=(\S+).*Hostname=(\S+).*DomainName=(\S+)/s);
 
    warning "DNS enabled state isn't set to yes. Currently set to $dns_state." and $error++ unless $dns_state =~ /yes/;
    warning "DNS host name isn't set correctly. Currently set to $dns_hostname." and $error++ unless $dns_hostname =~ /$ilo/;
    warning "DNS domain isn't set correctly. Currently set to $dns_domain." and $error++ unless $dns_domain =~ /bloomberg.com/;
 
    section_print($error, "DNS", $failure_array);
    return $error;
}
 
sub config_ssh_dhcp {
    my ($ssh, $model, $ticket_text) = @_;
    my ($rcode, $output);
 
    if ($model =~ /^proliant bl/i) {
        logit "Making sure DHCP is on for blades.";
        #Enabling DHCP for blades
        ($rcode, $output) = $ssh->runit("set /map1/dhcpendpt1/ EnabledState=yes");
        ($rcode, $output) = $ssh->runit("set /map1/settings1/WINSSettingData1 DHCPOptionToUse=yes");
        ($rcode, $output) = $ssh->runit("set /map1/settings1/DNSSettings1 DHCPOptionToUse=yes");
        ($rcode, $output) = $ssh->runit("set /map1/settings1/DNSSettings1 oemhp_UseDHCPv4DomainName=yes");
        ($rcode, $output) = $ssh->runit("set /map1/settings1/DNSSettings1 oemhp_UseDHCPv4Gateway=yes", 2);
        ($rcode, $output) = $ssh->runit("set /map1/settings1/StaticIPSettings1 DHCPOptionToUse=yes");
    } else {
        logit "Disabling DHCP since this is not a blade.";
        #Disabling DHCP on non-blades
        ($rcode, $output) = $ssh->runit("set /map1/dhcpendpt1/ EnabledState=no");
    }
 
    $$ticket_text .= " DHCP settings,";
}
 
sub check_ssh_dhcp {
    my ($ssh, $model, $failure_array) = @_;
    my ($rcode, $output);
    my $error = 0;
 
    ($rcode, $output) = $ssh->runit("show /map1/dhcpendpt1/");
    my ($dhcp_enabled) = ($output =~ /EnabledState=(.*)/m);
 
    # Get Model type DL or BL for DHCP state.
    if ($model =~ /proliant bl/i) {
        ($rcode, $output) = $ssh->runit("show /map1/settings1/WINSSettingData1");
        my ($dhcp_win_setting) = ($output =~ /DHCPOptionToUse=(.*)/m);
 
        ($rcode, $output) = $ssh->runit("show /map1/settings1/DNSSettings1");
        my ($dhcp_domain, $dhcp_dns_use, $dhcp_dns_domain) = ($output =~ /.*DomainName=(\S+).*DHCPOptionToUse=(\S+).*oemhp_UseDHCPv4DomainName=(\S+)/s);
 
        ($rcode, $output) = $ssh->runit("show /map1/settings1/StaticIPSettings1");
        my ($dhcp_ip_address_option) = ($output =~ /DHCPOptionToUse=(\S+)/m);
 
        #Logic for blades
        warning "DHCP is not set correctly." and $error++ unless $dhcp_enabled =~ /yes/;
        warning "WIN Settings are not set correctly." and $error++ unless $dhcp_win_setting =~ /yes/;
        warning "DHCP DNS setting is not set correctly." and $error++ unless $dhcp_dns_use =~ /yes/;
        warning "DHCP Domain setting is not set correctly." and $error++ unless $dhcp_domain =~ /bloomberg.com/;
        warning "DHCP Domain use setting is not set correctly." and $error++ unless $dhcp_dns_domain=~ /yes/;
        warning "DHCP Static IP setting is not set correctly." and $error++ unless $dhcp_ip_address_option =~ /yes/;
    } else {
        #Logic for DL/SL machines (rack mounted)
        warning "DHCP is not set correctly." and $error++ unless $dhcp_enabled =~ /no/;
    }
    section_print($error, "DHCP", $failure_array);
    return $error;
}
 
sub config_ssh_general {
    my ($ssh, $model, $ilo, $server, $ticket_text) = @_;
    my ($rcode, $output);
 
    # Get Model type DL or BL for license key and DHCP state.
    ($rcode, $output) = $ssh->runit("show /system1/ name");
    my ($ilo_model) = ($output =~ /\s+name=(.*)/mi);
 
    if ($ilo_model =~ /Unavailable/i) {
        logit "[INFO] Model is UNAVAILABLE in the iLO. Skipping BDMS model check.";
    } elsif ($ilo_model =~ /(proliant) ([dbs]l\d+[pc]?) g(?:en)?(\d+)/i) {
        warning "Models between BDMS and the iLO don't match. BDMS model: $model. iLO model: $ilo_model" unless $model =~ /$1 $2 g(en)?$3/i;
    } else {
        logit "[INFO] Model is not in a recognized format in the iLO. Skipping BDMS model check. iLO model: $ilo_model.";
    }
 
    my $license;
    if ($model =~ /^proliant bl/i) {
        $license = "32TS9TZRQQ4GHV6JGMRZ7V9DW"; #Blade License
    } elsif ($model =~ /^proliant (dl|sl)/i) {
        $license = "32TSB2XMLHS4NR9LPT2M435NR"; #DL or SL License
    } else {
        return error "BDMS model didn't match \"proliant [bl | dl | sl]\".";
    }
 
    logit "Applying the license key.";
 
    #Assigning the license key
    ($rcode, $output) = $ssh->runit("set /map1 license=$license");
 
    #Setting the iLO baud rate
    ($rcode, $output) = $ssh->runit("set /map1/config1/ oemhp_serialclispeed=115200");
 
    logit "Setting the server names.";
 
    eval {
        ($rcode, $output) = $ssh->runit("set /system1 oemhp_server_name=$server");
    };
    if ($@ =~ /status=2\s+status_tag=COMMAND PROCESSING FAILED/s) {
        error "Error occured while attempting to set the name. This is usually caused by the server POSTing and not being able to change the name during that time. Please wait until POST is completed or shut down the host.";
    }
 
    ($rcode, $output) = $ssh->runit("set /map1/enetport1/ SystemName=$ilo");
    
    $$ticket_text .= " general settings,";
}
 
sub check_ssh_general {
    my ($ssh, $model, $ilo, $failure_array) = @_;
    my ($rcode, $output);
    my $error = 0;
    
    #Checking the iLO baud rate
    ($rcode, $output) = $ssh->runit("show /map1/config1/ oemhp_serialclispeed");
    my ($baud_rate) = ($output =~ /oemhp_serialclispeed=(\S+)/m);
    warning "Baud rate is set to $baud_rate instead of 115200." and $error++ unless $baud_rate =~ /115200/;
 
    #Checking the server names
    my ($server) = ($ilo =~ /(.*?)(-ilo|-mgmt|m|(m|ilo)-(ob|temp))$/);
    ($rcode, $output) = $ssh->runit("show /system1 oemhp_server_name");
    my ($server_name) = ($output =~ /oemhp_server_name=(\S+)/m);
    warning "Server name isn't set correctly. Currently set to $server_name." and $error++ unless $server_name =~ /^$server(.bloomberg.com)?$/;
 
    ($rcode, $output) = $ssh->runit("show /map1/enetport1/ SystemName");
    my ($ilo_name) = ($output =~ /SystemName=(\S+)/m);
    warning "iLO name isn't set correctly. Currently set to $ilo_name." and $error++ unless $ilo_name =~ /^$ilo$/;
 
    #Check model
    ($rcode, $output) = $ssh->runit("show /system1/ name");
    my ($ilo_model) = ($output =~ /\s+name=(.*)/mi);
 
    if ($ilo_model =~ /Unavailable/i) {
        logit "[INFO] Model is UNAVAILABLE in the iLO. Skipping BDMS model check.";
    } elsif ($ilo_model =~ /(proliant) ([dbs]l\d+[pc]?) g(?:en)?(\d+)/i) {
        warning "Models between BDMS and the iLO don't match. BDMS model: $model. iLO model: $ilo_model" and $error++ unless $model =~ /$1 $2 g(en)?$3/i;
    } else {
        logit "[INFO] Model is not in a recognized format in the iLO. Skipping BDMS model check. iLO model: $ilo_model.";
    }
 
    ($rcode, $output) = $ssh->runit("show /map1 license");
    my ($license) = ($output =~ /license=\S+(\S{5})$/m);
    if ($model =~ /proliant bl/i) {
        #Full license: 32TS9TZRQQ4GHV6JGMRZ7V9DW
        warning "License key is incorrect for BL series. It is currently set to $license." and $error++ unless $license =~ /7V9DW/i;
    #Logic for DL/SL machines (rack mounted)
    } else {
        #Full license: 32TSB2XMLHS4NR9LPT2M435NR
        warning "License key is incorrect for DL/SL series. It is currenty set to $license." and $error++ unless $license =~ /435NR/i;
    }
    section_print($error, "GENRAL", $failure_array);
    return $error;
}
 
sub config_ssh_migrate {
    my ($ssh) = @_;
    my ($rcode, $output);
 
    logit "Blanking out the names and enabled DHCP.";
 
    ($rcode, $output) = $ssh->runit("set /system1 oemhp_server_name=\" \"");
 
    ($rcode, $output) = $ssh->runit("set /map1/enetport1/ SystemName=\"blank\"");
 
    ($rcode, $output) = $ssh->runit("set /map1/dhcpendpt1/ EnabledState=yes");
}
 
#Sub to initialize the SSH connection, make sure it can run commands and grab the iLO FW and version
sub ssh_connect {
    my ($password, $ilo, $user, %args) = @_;
    my ($output, $rcode);
 
    my $ssh = Net::SSH::Expect->new(host => $ilo, user => $user, password => $password, raw_pty => 1, timeout => 30, ssh_option => SSHOPTS);
    $ssh->run_ssh() or return error "Could not run SSH";
 
    logit "Attempting to log in via ssh...";
    $output = $ssh->login();
    error "Unsuccessfully logged in via ssh" unless $output;
    if ($output =~ /\'s password/) {
        logit "Initial password didn't authenticate, please try another.";
        $password = get_password("Administrator");
        $output = $ssh->exec($password);
        error "The passwords you entered didn't authenticate: $output" if $output !~ /hpiLO/;
    } else {
        error "Bad output received while trying to login: $output" if $output !~ /hpiLO/;
    }
    logit "Successfully logged in via ssh!"; 
 
    #Catching this one error because it could be related to firmware
    eval { 
        #Get the version of iLO
        ($rcode, $output) = $ssh->runit("show /map1"); 
    };
    if ($@ =~ /Timed out/) {
        return error "Timed out trying to run the first command; you may need to upgrade the firmware to the latest version.";
    }
 
    return error "Bad response from getting the iLO version: $output" if ($rcode != 0);
    my ($ilo_version) = ($output =~ /^\s+name=iLO\s(\d)\s(Advanced|Standard)/m);
    error "Unable to determine the iLO version." unless defined $ilo_version;
 
    ($rcode, $output) = $ssh->runit("show /map1/firmware1");
    my ($ilo_fw) = ($output =~ /^\s+version=(\d+\.\d+)$/m);
    error "Unable to determine the iLO firmware revision." unless defined $ilo_fw;
 
    if (defined $args{config}) {
        #Turning off auto iLO restart
        if ($ilo_version == 3 or $ilo_version == 4) {
            ($rcode, $output) = $ssh->runit("set /map1/ manual_iLO_reset=yes");
        } else {
            return error "Version isn't iLO3 or iLO4, exiting ...";
        }
    }
 
    return ($ssh, $ilo_version, $ilo_fw);
}
 
#Sub to grab data from the BDMS perl module
sub get_bdms_data {
    my ($host) = @_;
 
    #Getting chassis object out of BDMS
    my $host_hash = $BDMS::Hosts{$host};
    error "Unable to find ${host}'s host in BDMS." unless defined $host_hash;
 
    my $hw_hash;
    #Sometimes the connection between host and hardware record is broken, in these cases we have
    #to try to directly use the hardware object
    if (!defined $host_hash->{chassiss}[0]) {
        $hw_hash = $BDMS::Hardwares{$host};
    #Because BDMS has nested chassis/jbod/ blade architecture, if it comes up 
    #check to see which of them is the "proliant" series (JBOD and chassis aren't Proliant
    } else {
        my $amount_of_chassiss = @{$host_hash->{chassiss}};
        #Loop through every chassis entry and look for the proliant model
        for my $i (1..$amount_of_chassiss) {
            if ($host_hash->{chassiss}[$i-1]{model} =~ /proliant/i) {
                $hw_hash = $host_hash->{chassiss}[$i-1];
                last;
            }
        }
    }
    error "Unable to find ${host}'s hardware in BDMS." unless defined $hw_hash;
 
 
    my $manufacturer = $hw_hash->{manu};
    error "Manufacturer for $host is not HP in BDMS." unless $manufacturer =~ /hewlett packard/i;
 
    my $model = $hw_hash->{model};
    error "Unable to determine ${host}'s model in BDMS." unless defined $model;
 
    my $serial = $hw_hash->{serial};
    error "Unable to determine ${host}'s SN in BDMS." unless defined $serial;
 
    my $cabinet = $hw_hash->{cabinet};
    error "Unable to determine ${host}'s cabinet in BDMS." unless defined $cabinet;
 
    my $dc = $hw_hash->{dc};
    error "Unable to determine ${host}'s data center in BDMS." unless defined $dc;
 
    return ($model, $serial, $cabinet, $dc);
}
 
#Attempts to ping the host and returns 1 if pingable, 0 if not
sub ping {
    my $host = shift;
    my $timeout = shift;
 
    system("PATH=/usr/sbin:/sbin:/bin:/usr/bin ping $host $timeout >/dev/null 2>&1");
    my $rc = ($? >> 8);
    if ($rc == 0) {
        #It's pinging
        debug "$host is pingable.";
        return 1;
    } elsif ($rc == 1) {
        #not reachable
        debug "$host is not pingable.";
        return 0;
    } else {
        error "unable to execute the ping command";
    }
}
 
#Sub to update DHCP with the MAC address
sub dhcp_update {
    my ($ilo, $mac, $drqs, $tmln) = @_;
 
    my $cmd = DHCP_UPDATE_SCIRPT . " -y --profile lom";
 
    if (defined $mac){
        $mac = normalize_mac($mac);
        error "MAC address is invalid." unless ($mac =~ /^(([0-9A-F]{2}:){5}([0-9A-F]{2}))$/i);
        $cmd .= qq( --mac $mac ) ;
    } else {
        error "MAC was not defined but a DHCP update was required. Cannot continue.";
    }
 
    if(defined $drqs){
        ($drqs) = $drqs =~ /^([0-9]+)$/ or error "DRQS must only contain numbers.";
        $cmd .= qq( --drqs $drqs );
    } elsif (defined $tmln) {
        ($tmln) = $tmln =~ /^([0-9]+)$/ or error "TMLN must only contain numbers.";
        $cmd .= qq( --tmln $tmln )
    }
 
    $cmd .= qq($ilo);  
    debug $cmd;
    system($cmd);
    error "Cannot continue without network connectivity." if $?;
    logit "Trying to ping $ilo before proceeding. This may take a few minutes.";
 
    #Keep trying to ping before proceeding
    if (ping($ilo,300)){
        logit "$ilo is on the network now. Continuing...";
        return;
    } else {
        error "Couldn't ping $ilo  -- Cannot continue";
    }
}
 
sub lookup_password {
    my ($user) = @_;
    my $domid = 316;
    my $key = PASSWORD_KEY;
    my $cert = PASSWORD_CERT;
 
    my $get = BPV_SCRIPT . " -d $domid -k $key -c $cert -n $user";
    debug $get;
    my $pw = qx($get);
    chomp $pw;
    if ($pw) {
        return $pw;
    # If a regular user is running this, go interactive
    } elsif (DCSI::Sudo->realname() ne "dcsi") {
        $pw = get_password($user);
        return $pw;
    # If no password is returned and its the DCSI user
    # it means we are in auto mode with no interactive option
    } else {
        error "Couldn't lookup the password.";
    }
}
 
#Quick sub to take a query and capture the response
sub prompt {
    my ($query) = @_; #take a prompt string as argument
    local $| = 1; # activate autoflush to immediately show the prompt
    print $query;
    my $answer = <>;
    chomp $answer;
    return $answer;
}
 
#Sub to update DRQS tickets
sub update_DRQS {
    my ($drqs, $ilo, $action, $ticket_text) = @_;
    my $cmd;
    debug "DRQS: $drqs";
    debug "HOST: $ilo";
 
    my $uid = DC_ENG_UID;
    if ($action =~ /config/) {
        $cmd = UPD_DRQS_SCRIPT . qq( -u $uid -d $drqs -t "$ticket_text" -a lanserv -m);
    } elsif ($action =~ /check/) {
        $cmd = UPD_DRQS_SCRIPT . qq( -u $uid -d $drqs -t "$ticket_text" -a lanserv -m);
    } else {
        error "Invalid action: $action";
    }
    debug "DRQSUPDATE: $cmd";
    my $update = qx($cmd);
    error "Did not update the DRQS." if $?;
    logit "Successfully updated $drqs.";
}
 
#Sub to update TMLN tickets
sub update_TMLN {
    use DCSI::TMLN;
    my ($tmln, $ilo, $action, $ticket_text) = @_;
    my ($type, $data);
 
    my $uid = DC_ENG_UID;
    my $tmlnupdate = DCSI::TMLN->service($uid);
    debug "TMLN1: $tmlnupdate";
    ($type, $data) = $tmlnupdate->update($tmln+0, "$ticket_text") if $action =~ /config/;
    ($type, $data) = $tmlnupdate->update($tmln+0, "$ticket_text") if $action =~ /check/;
    debug "TMLN2: $tmlnupdate, response type $type";
    debug "TMLNUPDATE: $tmlnupdate";
    logit "Successfully updated $tmln.";
}
 
#Prompts for the MAC and normalizes it
sub get_mac {
    while() {
        my $mac = prompt("Enter MAC Address: ");
        $mac = normalize_mac($mac);
        return $mac if defined $mac;
    }
}
 
#Makes sure the MAC is valid and formats it
sub normalize_mac {
    my $input = shift;
    use Net::MAC;
 
    my $mac = Net::MAC->new(mac => $input); 
 
    if (!defined $mac) {
        debug "Bad MAC entered: $input.";
        warning "MAC is not a valid.";
        return undef; 
    } else {
        debug "MAC address is: $mac.";
        return $mac->as_IEEE();
    }
}
 
#Grabs the XML piece for NTP configuration
sub config_ribcl_ntp {
    my ($ntp, $ticket_text) = @_;
 
    my $sntp = "<SNTP_SERVER1 value=\"$ntp->[0]\" />" .
               "<SNTP_SERVER2 value=\"$ntp->[1]\" />";
 
    my $xml = 
        '<MOD_NETWORK_SETTINGS>' .
        ' <DHCP_SNTP_SETTINGS value="No"/>' .
        ' <DHCPv6_SNTP_SETTINGS value="No"/>' .
           $sntp .
        ' <TIMEZONE value="America/New_York"/>' .
        '</MOD_NETWORK_SETTINGS>';
 
    $$ticket_text .= " NTP settings,";
    return $xml;
}
 
#Grabs the XML for the Administrator key
sub config_ribcl_accounts {
    my ($key_location, $ticket_text) = @_;
 
    my $key = get_key($key_location);
 
    my $xml = 
        '<IMPORT_SSH_KEY>' .
        '-----BEGIN SSH KEY-----' .
        $key .
        '-----END SSH KEY-----' .
        '</IMPORT_SSH_KEY>';
 
    $$ticket_text .= " SSH keys,";
    return $xml;
}
 
#Grabs the XML for resetting the iLO back to factory default
sub config_ribcl_reset {
    my $xml = "<FACTORY_DEFAULTS/>";
 
    return $xml;
}
 
#Takes the XML that we generated above and wraps the request around it
sub create_xml {
    my ($user, $password, $xml_data) = @_;
 
 
    my $xml = 
<<XML;
    <?xml version="1.0"?>
    <LOCFG VERSION="2.0"/>
    <RIBCL VERSION="2.0">
      <LOGIN USER_LOGIN="$user" PASSWORD="$password">
        <RIB_INFO MODE="write">
        $xml_data
        </RIB_INFO>
      </LOGIN>
    </RIBCL>
XML
 
    return $xml;
}
 
#Takes the XML and runs it against the iLO, providing error checking inside of it
sub xml_ribcl_submit {
    my ($ilo, $xml) = @_;
 
    debug "XML Output:\n$xml";
 
    my $ua = new LWP::UserAgent;
    my $req = POST("https://$ilo/ribcl", Content_Type => "application/x-www-form-urlencoded", Content => $xml);
 
    my $output = $ua->request($req)->content; debug "Received:\n$output";
    if ($output !~ /<RIBCL/) {
        return error "No RIBCL output received, is this an HP?";
    }
  
    my $index = 0;
    my $errorCount = 0;
    while($output =~ /(\<RIBCL.*?\>.*?\<\/RIBCL\>)/msg){
        my $results = $1;
        $index++;
        my $xml = eval "XMLin(\$results)";
        if($@) {
            error "Command $index: Error parsing results";
            next;
        }
        my $response = $xml->{RESPONSE};
        if (!defined $response) {
            error "Command $index: No response element found in response";
            next;
        }
        debug "Command $index: $response->{MESSAGE} ($response->{STATUS})";
        if ($response->{STATUS} ne "0x0000" && $response->{MESSAGE} !~ /not supported/i) {
            error "Command $index: $response->{MESSAGE} ($response->{STATUS})";
            $errorCount++;
        }
    }
    error "Errors reported while attempting to configure via RIBCL" if $errorCount;
    logit "Successfully applied XML configuration.";
    return 0;
}
 
#Sub to get the administrator public key
sub get_key {
    my ($keyfile) = @_;
    my $key;
 
    ##Note the comment in the key file is required to be the username with HP iLOs.
    {
        open my $FH, $keyfile or error "Couldn't open $keyfile";
        $key = <$FH>;
        error "Invalid key (must be DSS)." unless $key =~ /^(ssh-dss [a-zA-z0-9+\/=]+ \S+)$/;
        $key = $1;
        close $FH;
    }
    return $key;
}
 
#Sub to grab the password
sub get_password {
    my $user = shift;
    my $password;
    my $password2;
    if (!defined $ENV{"${user}_PASSWORD"}) {
        while(1){
            print "$user\'s password: ";
            ReadMode('noecho');
            $password = <>;
            chomp $password;
            print "\n$user\'s password again: ";
            ReadMode('noecho');
            $password2 = <>;
            chomp $password2;
            last if $password eq $password2;
            print "\n*****Passwords do not match*****\n";
        }
        ReadMode(0);
        print "\n";
    } else {
        $password = $ENV{"${user}_PASSWORD"};
    }
    
    error "PASSWORD has illegal characters" if $password !~ /^([!\@#\$\%\^\&*\(\)0-9a-zA-Z]+)$/;
    debug "Using password: $password";
    return $password;
}
 
#Sub to grab the JSON config file and returns back the hash reference
sub consume_json_config {
    my $json_text;
 
    #Grabbing the json config file
    {
        open(my $FH, '<', JSON_CONFIG_FILE) or die "Cannot open " . JSON_CONFIG_FILE;
        $json_text = <$FH>;
        close $FH;
    }
    
    #Return the json object, it is a SCALAR
    return decode_json($json_text);
}
 
#Reads the file provided
sub parse_file {
    my ($file_location) = @_;
    my @master_array;
 
    #Opening the file;
    open(my $FH, $file_location) or die "Couldn't open $file_location.";
 
    my $line_num = 0;
    while (++$line_num and my $line = <$FH>) {
        my %temp_hash;
        #FILE FORMAT SHOULD BE:
        #^host,action,config,target,profile,mac,initialpw,ticket(or noticket) and number$
        error "Line: $line_num: invalid line format:\n$line\n"
            unless $line =~ /^(.*),(.*),(.*),(.*),(.*),(.*),(.*),(.*)$/;
 
        #Setting values per the file
        my ($ilo, $action, $config, $target, $profile, $mac, $initialpw, $ticket) 
            = ($line =~ /^(.*),(.*),(.*),(.*),(.*),(.*),(.*),(.*)$/);
 
        error "Line: $line_num: invalid iLO name: $ilo"if $ilo !~ /(-mgmt|-ilo|m|(m|ilo)-(ob|temp))$/i;
        $temp_hash{ilo} = $ilo;
 
        error "Line: $line_num: invalid action: $action" unless $action =~ /(check|config)/;
        $temp_hash{action} = $action;
 
        error "Line: $line_num: invalid configuration type: $config" unless $config =~ /(all|general|accounts|dns|dhcp|ldap|snmp|ntp|migrate)/;
        $temp_hash{config} = $config;
 
        if ($action =~ /config/) {
            error "Line: $line_num: invalid target: $target" if $config =~ /(all|snmp)/ and defined $target and $target !~ /(lanserv|sim)/;
            $temp_hash{target} = $target if $target =~ /\S+/;
 
            error "Line: $line_num: invalid profile: $profile" if $config =~ /(all|ldap)/ and defined $profile and $profile !~ /(bach|infosys|cas|dc|bfs|cloud|esx|windows|linux|netops)/;
            $temp_hash{profile} = $profile if $profile =~ /\S+/;
        }
 
        $temp_hash{mac} = $mac if $mac =~ /\S+/;
        $temp_hash{initialpw} = $initialpw if $initialpw =~ /\S+/;
 
        #Processing and adding the ticket
        my ($ticket_type, $ticket_number) = ($ticket =~ /(noticket|drqs|tmln)(?: (\d+))?/i);
        error "Line: $line_num: invalid ticket type" unless defined $ticket_type;
        error "Line: $line_num: ticket number required for ticket: $ticket_type" if $ticket_type =~ /(drqs|tmln)/i and !defined $ticket_number;
        $temp_hash{ticket_type} = $ticket_type;
        $temp_hash{ticket_number} = $ticket_number if defined $ticket_number;
    
        #Push each hash entry into my array
        push (@master_array, \%temp_hash);
 
    }
 
    close($FH);
 
    return @master_array;
}
 
#Main subroutine that performs all of the heavy lifting
sub main {
    #Defining the getopts variables
    my ($all, $general, $accounts, $dns, $dhcp, $ldap, $snmp, $ntp, $target, $profile, $file, 
            $mac, $drqs, $tmln, $initialpw, $resetilo, $noticket, $action, $migrate);
 
    GetOptions(
        "all"           => \$all,
        "general"       => \$general,
        "accounts"      => \$accounts,
        "dns"           => \$dns,
        "dhcp"          => \$dhcp,
        "ldap"          => \$ldap,
        "snmp"          => \$snmp,
        "ntp"           => \$ntp,
        "migrate"       => \$migrate,
        "action=s"      => \$action,
        "target=s"      => \$target,
        "profile=s"     => \$profile,
        "file=s"        => \$file,
        "debug"         => \$DEBUG,
        "mac=s"         => \$mac,
        "drqs=i"        => \$drqs,
        "tmln=i"        => \$tmln,
        "initialpw=s"   => \$initialpw,
        "resetilo"      => \$resetilo,
        "noticket"      => \$noticket,
    ) or usage;
 
    #We don't allow mass iLO reset
    usage "Cannot run resetilo with the file option." if defined $resetilo and defined $file;
 
    my (@input_array);
    #If --file isn't specified, create the usage hash for 1 machine
    if (!defined $file) {
        #Host given (not --file). Create usage hash
        usage "Missing the iLO name." unless @ARGV == 1;
        my ($ilo, %usage_hash);
        ($ilo) = ((shift @ARGV) =~ /^([-a-zA-Z0-9\.]+)$/);
        $ilo = lc($ilo);
        $usage_hash{ilo} = $ilo;
        $usage_hash{action} = $action;
        $usage_hash{config} .= " all" if defined $all;
        $usage_hash{config} .= " general" if defined $general; 
        $usage_hash{config} .= " accounts" if defined $accounts; 
        $usage_hash{config} .= " dns" if defined $dns; 
        $usage_hash{config} .= " dhcp" if defined $dhcp; 
        $usage_hash{config} .= " ldap" if defined $ldap; 
        $usage_hash{config} .= " snmp" if defined $snmp; 
        $usage_hash{config} .= " ntp" if defined $ntp; 
        $usage_hash{config} .= " migrate" if defined $migrate;
        $usage_hash{config} =~  s/^\s+// if (exists $usage_hash{config} and $usage_hash{config} =~ /^\s+/);
        $usage_hash{target} = $target if defined $target;
        $usage_hash{profile} = $profile if defined $profile;
        $usage_hash{mac} = $mac if defined $mac;
        $usage_hash{initialpw} = $initialpw if defined $initialpw;
        $usage_hash{ticket_type} = "drqs" if defined $drqs;
        $usage_hash{ticket_number} = $drqs if defined $drqs;
        $usage_hash{ticket_type} = "tmln" if defined $tmln;
        $usage_hash{ticket_number} = $tmln if defined $tmln;
        $usage_hash{ticket_type} = "noticket" if defined $noticket;
        push (@input_array, \%usage_hash);
    } else { #--file was given, validate usage and handle file
        #Make sure no extra arguments were passed
        if (@ARGV != 0) {
            usage "Can only specify a host or the file option."
        }
 
        #If --file was given and any other options (except --debug), usage
        if (defined $file and (defined $all or defined $general or defined $accounts
                or defined $dns or defined $dhcp or defined $ldap or defined $snmp
                or defined $ntp or defined $target or defined $profile or defined $mac
                or defined $initialpw or defined $drqs or defined $tmln
                or defined $noticket)) {
            usage "Cannot specify anything with --file option except debug.";
        }
 
        $BATCH = 1;
        @input_array = parse_file($file) if $file; 
    }
 
    my $settings = consume_json_config();
 
    for my $iteration (@input_array) {
        #Now undef'n everything at the beginning of the loop or else config type will stick 
        $all = $general = $accounts = $dns = $dhcp = $ldap = $snmp = $ntp = $target =
        $profile = $mac = $initialpw = $drqs = $tmln = $noticket = undef;
 
        #Turn the hash elements into variables we can use
        my $ilo = $iteration->{ilo};
        $action = $iteration->{action};
        $target = $iteration->{target};
        $profile = $iteration->{profile};
        $mac = $iteration->{mac};
        $initialpw = $iteration->{initialpw};
        if (exists $iteration->{ticket_type} and $iteration->{ticket_type} =~ /drqs/i) {
            $drqs = $iteration->{ticket_number};
        } elsif (exists $iteration->{ticket_type} and $iteration->{ticket_type} =~ /tmln/i) {
            $tmln = $iteration->{ticket_number};
        } elsif (exists $iteration->{ticket_type} and $iteration->{ticket_type} =~ /noticket/i) {
            $noticket = 1;
        } else {
            $iteration->{ticket_type} = "blank";
            usage "Ticket type wasn't drqs, tmln or noticket. It was $iteration->{ticket_type}.";
        }
 
        #Initializing the configuration type depending on what was given
        $all = 1 if (exists $iteration->{config} and $iteration->{config} =~ /all/);
        $general = 1 if (exists $iteration->{config} and $iteration->{config} =~ /general/);
        $accounts = 1 if (exists $iteration->{config} and $iteration->{config} =~ /accounts/);
        $dns = 1 if (exists $iteration->{config} and $iteration->{config} =~ /dns/);
        $dhcp = 1 if (exists $iteration->{config} and $iteration->{config} =~ /dhcp/);
        $ldap = 1 if (exists $iteration->{config} and $iteration->{config} =~ /ldap/);
        $snmp = 1 if (exists $iteration->{config} and $iteration->{config} =~ /snmp/);
        $ntp = 1 if (exists $iteration->{config} and $iteration->{config} =~ /ntp/);
        $migrate = 1 if (exists $iteration->{config} and $iteration->{config} =~ /migrate/);
 
        #Checking the arguments
        usage "No action option given" if !defined $action;
        usage "Invalid action: $action" if $action !~ /(check|config)/;
        usage "No iLO name given" if !defined $ilo;
        usage "Invalid ILO name: $ilo" if $ilo !~ /(-mgmt|-ilo|m|(m|ilo)-(ob|temp))$/i;
        usage "No ticket option given " if (!defined $noticket and !defined $drqs and !defined $tmln);
        usage "No configuration type given" unless defined $all or (defined $general 
            or defined $accounts or defined $dns or defined $dhcp or defined $ldap 
            or defined $snmp or defined $ntp or defined $migrate or defined $resetilo);
 
        if ($action =~ /config/) {
            usage "No profile given" if ((defined $all or defined $ldap) and !defined $profile);
            usage "Invalid profile: $profile" 
                if ((defined $ldap or defined $all) and $profile !~ /^(esx|windows|linux|netops|cloud|bvlt|bach|infosys|bfs|cas|dc)$/i);
            usage "No target given" if ((defined $all or defined $snmp) and !defined $target);
            usage "Invalid target: $target" if ((defined $snmp or defined $all) and $target !~ /(sim|lanserv)/);
        }
        usage "Cannot run resetilo with the check action." if defined $resetilo and $action =~ /check/;
 
        #Define the user account we are using
        my $user = "Administrator";
        usage "Invalid username: must be only letters and numbers." if $user !~ /^[a-zA-Z0-9]+$/;
        debug "User: $user.";
 
 
        #Assigning the server names
        my ($server) = ($ilo =~ /(.*?)(-ilo|-mgmt|m|(m|ilo)-(ob|temp))$/);
 
        my ($model, $serial, $cabinet, $dc) = get_bdms_data($server);
 
        logit "Running $action on $ilo.";
 
        logit "Ping test. Trying to ping $ilo";
        if (ping($ilo,5)){
            logit "$ilo is already on the network. Continuing...";
        } else {
            logit "$ilo is not pingable. Configuring it for DHCP.";
            if (!defined $mac) {
                $mac = get_mac();
            }
            dhcp_update($ilo,$mac,$drqs,$tmln) if (!defined $resetilo);
        }
 
        my $ticket_text;
        my $realname = DCSI::Sudo->realname();
        #Reset the ILO if the reset flag is specified
        if (defined $resetilo) {
            if ($action =~ /config/) {
                $ticket_text .= "User $realname factory reset ${server}'s iLO.";
                logit "Resetting ILO to factory defaults";
                my $password = lookup_password("Administrator");
                my $xml = config_ribcl_reset();
                $xml = create_xml("Administrator", $password, $xml);
                xml_ribcl_submit($ilo, $xml);
                exit;
            } else {
                usage "--restilo option can only run with config action"; 
            }
        }
 
        #Grab the password if it isn't defined
        $initialpw = lookup_password($user) unless defined $initialpw;
 
        my ($ssh_session, $ilo_version, $ilo_fw) = ssh_connect($initialpw, $ilo, $user, $action => 1);
 
        logit "[INFO] iLO$ilo_version $ilo_fw";
 
        if (defined $migrate) { 
            if (defined $all or defined $all or defined $general or defined $accounts
                    or defined $dns or defined $dhcp or defined $ldap or defined $snmp or defined $ntp) {
                usage "--migrate option can't be used with any other configuration types";
            }
 
            if ($action =~ /config/) {
                $ticket_text .= "User $realname configured ${server}'s iLO for migration.";
                config_ssh_migrate($ssh_session);
            } else {
                usage "--migrate option can only run with config action.";
            }
        }
 
        my @failure_array;
        if ($action =~ /config/ and (defined $all or defined $general or defined $accounts or defined $dns
                                        or defined $dhcp or defined $ldap or defined $snmp or defined $ntp)) {
            $ticket_text .= "User $realname configured ${server}'s iLO:";
            #Must configure via SSH first, since RIBCL will trigger a reboot ..
            config_ssh_general($ssh_session, $model, $ilo, $server, \$ticket_text)                     if defined $all or defined $general;
            config_ssh_accounts($ssh_session, \$ticket_text)                                           if defined $all or defined $accounts;
            config_ssh_dhcp($ssh_session, $model, \$ticket_text)                                       if defined $all or defined $dhcp;
            config_ssh_dns($ssh_session, $ilo, $settings->{dns}, \$ticket_text)                        if defined $all or defined $dns;
            config_ssh_ldap($ssh_session, $profile, $ilo_version, $settings->{ldap}, \$ticket_text)    if defined $all or defined $ldap;
            config_ssh_snmp($ssh_session, $target, $ilo_version, $settings->{snmp}, \$ticket_text)     if defined $all or defined $snmp;
            #Doing the ribcl last because it will cause a reboot
            if ((defined $all) or (defined $ntp and defined $accounts)) {
                #Get the Administrator account password
                my $password = lookup_password("Administrator");
                my $xml .= config_ribcl_ntp($settings->{ntp}, \$ticket_text) ;
                $xml .= config_ribcl_accounts($settings->{ssh_key}{Administrator}, \$ticket_text);
                $xml = create_xml("Administrator", $password, $xml);
                xml_ribcl_submit($ilo, $xml);
            } elsif (defined $ntp) {
                #Get the Administrator account password
                my $password = lookup_password("Administrator");
                my $xml .= config_ribcl_ntp($settings->{ntp}, \$ticket_text);
                $xml = create_xml("Administrator", $password, $xml);
                xml_ribcl_submit($ilo, $xml);
            } elsif (defined $accounts) {
                #Get the Administrator account password
                my $password = lookup_password("Administrator");
                my $xml .= config_ribcl_accounts ($settings->{ssh_key}{Administrator}, \$ticket_text);
                $xml = create_xml("Administrator", $password, $xml);
                xml_ribcl_submit($ilo, $xml);
            } else {
                #No need to do ribcl so we need to exit the ssh session
                $ssh_session->close();
            }
 
            logit "[SUCCESS] confilo successfully configured $ilo.";
            logit "ILO is resetting and should be back in a minute or so!";
        } elsif ($action =~ /check/ and (defined $all or defined $general or defined $accounts or defined $dns
                                            or defined $dhcp or defined $ldap or defined $snmp or defined $ntp)) {
            $ticket_text = "User $realname checked ${server}'s iLO";
            my $total_error_count = 0;
            $total_error_count += check_ssh_general($ssh_session, $model, $ilo, \@failure_array)                   if defined $all or defined $general;
            debug "Total error count: $total_error_count";
            $total_error_count += check_ssh_accounts($ssh_session, \@failure_array)                                if defined $all or defined $accounts;
            debug "Total error count: $total_error_count";
            $total_error_count += check_ssh_dns($ssh_session, $ilo, $settings->{dns}, \@failure_array)             if defined $all or defined $dns;
            debug "Total error count: $total_error_count";
            $total_error_count += check_ssh_dhcp($ssh_session, $model, \@failure_array)                            if defined $all or defined $dhcp;
            debug "Total error count: $total_error_count";
            $total_error_count += check_ssh_ldap($ssh_session, $ilo_version, $settings->{ldap}, \@failure_array)   if defined $all or defined $ldap;
            debug "Total error count: $total_error_count";
            $total_error_count += check_ssh_snmp($ssh_session, $ilo_version, $settings->{snmp}, \@failure_array)   if defined $all or defined $snmp;
            debug "Total error count: $total_error_count";
 
            my $password = lookup_password("Administrator") if defined $all or defined $ntp;
            $total_error_count += check_ribcl_ntp($ilo, $password, $settings->{ntp}, \@failure_array)             if defined $all or defined $ntp;
            debug "Total error count: $total_error_count";
 
            logit "[SUCCESS] confilo successfully checked $ilo.";
            if ($total_error_count != 0) {
                logit "Please fix any warnings listed above." if $total_error_count != 0;
                $ticket_text .= " and it has $total_error_count errors:";
            } else {
                $ticket_text .= " and it is fully configured correctly.";
            }
        } else {
            error "Action was not specified." unless defined $migrate or defined $resetilo;
        }
 
        $ticket_text =~ s/,$/./ if $action =~ /config/;
        if (scalar @failure_array > 0) {
            my $i = 1;
            for my $entry (@failure_array) {
                $ticket_text .= "\n$entry";
            }
        }
 
        debug "Ticket text: $ticket_text";
 
        #Update the tickets if the noticket flag is specified
        if (!defined $noticket) {
            update_DRQS($drqs, $ilo, $action, $ticket_text) if defined $drqs;
            update_TMLN($tmln, $ilo, $action, $ticket_text) if defined $tmln;
        }
    }
}
main;
 
__END__
 
=pod

=head1 NAME
 
    confilo - Configures an HP iLO to the standard data center settings.

=head1 SYNOPSIS

=over 4

=item B<examples>

    confilo --action check --all pnj3-bach-r4n16-ilo --drqs 12345678
    confilo --action config --all --profile bach --target lanserv pnj3-bach-r4n16-ilo --tmln 123456
    confilo --action check --ldap --ntp pnj-comdb2ald1-ilo --noticket
    confilo --action config --ldap --profile linux pnj-comdb2ald1-ilo --drqs 12345678
    confilo --action config --snmp --target sim pnj-comdb2ald1-ilo --tmln 123456
    confilo --action config --resetilo njfe3396-ilo --noticket

=item B<required flags> 

    --action <check|config>                             Specifies what action you want to perform.
    --<all|<general|accounts|dns|dhcp|ldap|snmp|ntp>>   Specifies what you want to configure.
    --<tmln|drqs> <ticket number>                       What ticket to log against and update after.

=item B<conditional flags>
    
    --target <lanserv|sim>                                            Required if snmp or all is specified. Specifies where to send the SNMP traps.
    --profile <cas|dc|bfs|bach|bvlt|cloud|esx|windows|linux|infosys|netops>  Required if ldap or all is specified. Specifies what LDAP profile to apply.

=item B<configuration flags>

    Each flag will either configure or check depending on the action specified.
    You can add multiple options if --all isn't used (such as --ntp and --dns if you just want to do those)

    --all       all of the below options
    --general   general settings like name and iLO baud rate
    --accounts  Administrator account settings and keys
    --dns       DNS settings
    --dhcp      DHCP settings
    --ldap      LDAP groups (if config action it requires that the --profile flag be passed)
    --snmp      SNMP settings (if config action it requires that the --target flag be passed)
    --ntp       NTP settings

    Meant to be used alone with no other configuration flags:

    --resetilo                                  Will restore the iLO back to factory default.
    --migrate                                   Removes the names and turns DHCP. Intended for DC migrations.

=item B<optional flags>

    --mac <00:00:00:00:00:00|0000.0000.0000>    What MAC to use for DHCP configuration.
    --noticket                                  Will not update ticket with iLO config message.
    --initialpw <XXXXXXXX>                      What initial password to use to access the iLO.
    --debug                                     More chatty and posts additional output.
    --file                                      Will run in batch mode if a csv file is specified.
                                                File format should be lines that look like the following:
                                                ilo,action type,config type,target,profile,mac,initialpw,ticket
                                                  *If multiple config types (dns dhcp ntp etc.) space seperate them*
                                                Examples:
                                                devxob401m,check,all,,,,,,noticket
                                                devxob402m,config,all,sim,esx,,,,tmln 123456
                                                devxob403m,config,general snmp,sim,,,,,,drqs 12345678
                                                devxob404m,config,ldap ntp,,esx,,,noticket
                                                  *If a field isn't needed, just leave blank*

=back

=head1 DESCRIPTION

    confilo will configure an iLO to the data center standard settings. These settings include account 
    settings, static IP assignment, DNS settings, LDAP settings, SNMP settings, NTP settings, license 
    key assignment, server names and iLO VSP baud rate. 

=cut

